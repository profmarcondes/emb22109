/* Generated by itemis CREATE code generator. */

#ifndef TRAFFICLIGHTCTRL_H_
#define TRAFFICLIGHTCTRL_H_

/*!
Forward declaration for the TrafficLightCtrl state machine.
*/
class TrafficLightCtrl;


#include "sc_types.h"
#include "sc_statemachine.h"
#include "sc_cyclebased.h"
#include "sc_timer.h"
#include <string.h>

/*! \file
Header of the state machine 'TrafficLightCtrl'.
*/


class TrafficLightCtrl : public sc::timer::TimedInterface, public sc::CycleBasedInterface
{
	public:
		TrafficLightCtrl() noexcept;
		
		virtual ~TrafficLightCtrl();
		
		
		
		/*! Enumeration of all states. */
		enum class State
		{
			NO_STATE,
			main_region_on,
			main_region_on_r1_StreetGreen,
			main_region_on_r1_PedWaiting,
			main_region_on_r1_PedWaiting_r1_waitOn,
			main_region_on_r1_PedWaiting_r1_waitOff,
			main_region_on_r1_StreetAttention,
			main_region_on_r1_StreetRed,
			main_region_on_r1_PedestrianGreen,
			main_region_on_r1_PedestrianRed,
			main_region_on_r1_StreetPrepare,
			main_region_on_r1_Safe,
			main_region_off,
			main_region_off_r1_YellowOn,
			main_region_off_r1_YellowOff
		};
		
		/*! The number of states. */
		static constexpr const sc::integer numStates {14};
		static constexpr const sc::integer scvi_main_region_on {0};
		static constexpr const sc::integer scvi_main_region_on_r1_StreetGreen {0};
		static constexpr const sc::integer scvi_main_region_on_r1_PedWaiting {0};
		static constexpr const sc::integer scvi_main_region_on_r1_PedWaiting_r1_waitOn {0};
		static constexpr const sc::integer scvi_main_region_on_r1_PedWaiting_r1_waitOff {0};
		static constexpr const sc::integer scvi_main_region_on_r1_StreetAttention {0};
		static constexpr const sc::integer scvi_main_region_on_r1_StreetRed {0};
		static constexpr const sc::integer scvi_main_region_on_r1_PedestrianGreen {0};
		static constexpr const sc::integer scvi_main_region_on_r1_PedestrianRed {0};
		static constexpr const sc::integer scvi_main_region_on_r1_StreetPrepare {0};
		static constexpr const sc::integer scvi_main_region_on_r1_Safe {0};
		static constexpr const sc::integer scvi_main_region_off {0};
		static constexpr const sc::integer scvi_main_region_off_r1_YellowOn {0};
		static constexpr const sc::integer scvi_main_region_off_r1_YellowOff {0};
		/*! Raises the in event 'pedestrianRequest' of default interface scope. */
		void raisePedestrianRequest() noexcept;
		/*! Raises the in event 'onOff' of default interface scope. */
		void raiseOnOff() noexcept;
		
		
		//! Inner class for TrafficLight interface scope.
		class TrafficLight
		{
			public:
				explicit TrafficLight(TrafficLightCtrl* parent) noexcept;
				
				
				
				
				/*! Gets the value of the variable 'red' that is defined in the interface scope 'TrafficLight'. */
				bool getRed() const noexcept;
				
				/*! Sets the value of the variable 'red' that is defined in the interface scope 'TrafficLight'. */
				void setRed(bool red) noexcept;
				
				/*! Gets the value of the variable 'yellow' that is defined in the interface scope 'TrafficLight'. */
				bool getYellow() const noexcept;
				
				/*! Sets the value of the variable 'yellow' that is defined in the interface scope 'TrafficLight'. */
				void setYellow(bool yellow) noexcept;
				
				/*! Gets the value of the variable 'green' that is defined in the interface scope 'TrafficLight'. */
				bool getGreen() const noexcept;
				
				/*! Sets the value of the variable 'green' that is defined in the interface scope 'TrafficLight'. */
				void setGreen(bool green) noexcept;
				
				
				
				
			private:
				friend class TrafficLightCtrl;
				
				bool red {false};
				bool yellow {false};
				bool green {false};
				
				
				TrafficLightCtrl* parent;
				
				
				
				
				
		};
		
		/*! Returns an instance of the interface class 'TrafficLight'. */
		TrafficLight& trafficLight() noexcept;
		
		//! Inner class for Pedestrian interface scope.
		class Pedestrian
		{
			public:
				explicit Pedestrian(TrafficLightCtrl* parent) noexcept;
				
				
				
				
				/*! Gets the value of the variable 'request' that is defined in the interface scope 'Pedestrian'. */
				bool getRequest() const noexcept;
				
				/*! Sets the value of the variable 'request' that is defined in the interface scope 'Pedestrian'. */
				void setRequest(bool request) noexcept;
				
				/*! Gets the value of the variable 'red' that is defined in the interface scope 'Pedestrian'. */
				bool getRed() const noexcept;
				
				/*! Sets the value of the variable 'red' that is defined in the interface scope 'Pedestrian'. */
				void setRed(bool red) noexcept;
				
				/*! Gets the value of the variable 'green' that is defined in the interface scope 'Pedestrian'. */
				bool getGreen() const noexcept;
				
				/*! Sets the value of the variable 'green' that is defined in the interface scope 'Pedestrian'. */
				void setGreen(bool green) noexcept;
				
				
				
				
			private:
				friend class TrafficLightCtrl;
				
				bool request {false};
				bool red {false};
				bool green {false};
				
				
				TrafficLightCtrl* parent;
				
				
				
				
				
		};
		
		/*! Returns an instance of the interface class 'Pedestrian'. */
		Pedestrian& pedestrian() noexcept;
		
		//! Inner class for default interface scope operation callbacks.
		class OperationCallback
		{
			public:
				virtual ~OperationCallback() = 0;
				
				virtual void synchronize() = 0;
				
				
		};
		
		/*! Set the working instance of the operation callback interface 'OperationCallback'. */
		void setOperationCallback(OperationCallback* operationCallback) noexcept;
		
		
		/*
		 * Functions inherited from StatemachineInterface
		 */
		 void enter() override;
		
		 void exit() override;
		
		void runCycle() override;
		
		/*!
		 * Checks if the state machine is active (until 2.4.1 this method was used for states).
		 * A state machine is active if it has been entered. It is inactive if it has not been entered at all or if it has been exited.
		 */
		 bool isActive() const noexcept override;
		
		
		/*!
		* Checks if all active states are final. 
		* If there are no active states then the state machine is considered being inactive. In this case this method returns false.
		*/
		 bool isFinal() const noexcept override;
		
		/*! 
		 * Checks if member of the state machine must be set. For example an operation callback.
		 */
		bool check() const noexcept;
		
		/*
		 * Functions inherited from TimedStatemachineInterface
		 */
		void setTimerService(sc::timer::TimerServiceInterface* timerService_) noexcept override;
		
		sc::timer::TimerServiceInterface* getTimerService() noexcept override;
		
		void raiseTimeEvent(sc::eventid event) noexcept override;
		
		sc::integer getNumberOfParallelTimeEvents() noexcept override;
		
		
		
		/*! Checks if the specified state is active (until 2.4.1 the used method for states was calles isActive()). */
		bool isStateActive(State state) const noexcept;
		
		//! number of time events used by the state machine.
		static const sc::integer timeEventsCount {12};
		
		//! number of time events that can be active at once.
		static const sc::integer parallelTimeEventsCount {3};
		
		
	protected:
		
		
		
		
	private:
		TrafficLightCtrl(const TrafficLightCtrl &rhs);
		TrafficLightCtrl& operator=(const TrafficLightCtrl&);
		
		
		
		
		
		
		//! the maximum number of orthogonal states defines the dimension of the state configuration vector.
		static const sc::ushort maxOrthogonalStates {1};
		
		sc::timer::TimerServiceInterface* timerService;
		bool timeEvents[timeEventsCount];
		
		
		State stateConfVector[maxOrthogonalStates];
		
		
		TrafficLight ifaceTrafficLight {TrafficLight{nullptr}};
		Pedestrian ifacePedestrian {Pedestrian{nullptr}};
		
		OperationCallback* ifaceOperationCallback;
		
		typedef struct {
			bool pedestrianRequest_raised;
			bool onOff_raised;
		}TrafficLightCtrlIfaceEvBuf;
		typedef struct {
			bool TrafficLightCtrl_main_region_on_r1_PedWaiting_time_event_0_raised;
			bool TrafficLightCtrl_main_region_on_r1_PedWaiting_r1_waitOn_time_event_0_raised;
			bool TrafficLightCtrl_main_region_on_r1_PedWaiting_r1_waitOff_time_event_0_raised;
			bool TrafficLightCtrl_main_region_on_r1_StreetAttention_time_event_0_raised;
			bool TrafficLightCtrl_main_region_on_r1_StreetRed_time_event_0_raised;
			bool TrafficLightCtrl_main_region_on_r1_PedestrianGreen_time_event_0_raised;
			bool TrafficLightCtrl_main_region_on_r1_PedestrianRed_time_event_0_raised;
			bool TrafficLightCtrl_main_region_on_r1_StreetPrepare_time_event_0_raised;
			bool TrafficLightCtrl_main_region_on_r1_Safe_time_event_0_raised;
			bool TrafficLightCtrl_main_region_off_r1_YellowOn_time_event_0_raised;
			bool TrafficLightCtrl_main_region_off_r1_YellowOff_time_event_0_raised;
			bool TrafficLightCtrl_time_event_0_raised;
		}TrafficLightCtrlTimeEventsEvBuf;
		typedef struct {
			TrafficLightCtrlIfaceEvBuf iface;
			TrafficLightCtrlTimeEventsEvBuf timeEvents;
		}TrafficLightCtrlEvBuf;
		TrafficLightCtrlEvBuf current {};
		bool isExecuting {false};
		
		
		
		// prototypes of all internal functions
		
		void enact_main_region_on_r1_StreetGreen();
		void enact_main_region_on_r1_PedWaiting();
		void enact_main_region_on_r1_PedWaiting_r1_waitOn();
		void enact_main_region_on_r1_PedWaiting_r1_waitOff();
		void enact_main_region_on_r1_StreetAttention();
		void enact_main_region_on_r1_StreetRed();
		void enact_main_region_on_r1_PedestrianGreen();
		void enact_main_region_on_r1_PedestrianRed();
		void enact_main_region_on_r1_StreetPrepare();
		void enact_main_region_on_r1_Safe();
		void enact_main_region_off();
		void enact_main_region_off_r1_YellowOn();
		void enact_main_region_off_r1_YellowOff();
		void exact_main_region_on_r1_PedWaiting();
		void exact_main_region_on_r1_PedWaiting_r1_waitOn();
		void exact_main_region_on_r1_PedWaiting_r1_waitOff();
		void exact_main_region_on_r1_StreetAttention();
		void exact_main_region_on_r1_StreetRed();
		void exact_main_region_on_r1_PedestrianGreen();
		void exact_main_region_on_r1_PedestrianRed();
		void exact_main_region_on_r1_StreetPrepare();
		void exact_main_region_on_r1_Safe();
		void exact_main_region_off_r1_YellowOn();
		void exact_main_region_off_r1_YellowOff();
		void enseq_main_region_on_default();
		void enseq_main_region_on_r1_StreetGreen_default();
		void enseq_main_region_on_r1_PedWaiting_default();
		void enseq_main_region_on_r1_PedWaiting_r1_waitOn_default();
		void enseq_main_region_on_r1_PedWaiting_r1_waitOff_default();
		void enseq_main_region_on_r1_StreetAttention_default();
		void enseq_main_region_on_r1_StreetRed_default();
		void enseq_main_region_on_r1_PedestrianGreen_default();
		void enseq_main_region_on_r1_PedestrianRed_default();
		void enseq_main_region_on_r1_StreetPrepare_default();
		void enseq_main_region_on_r1_Safe_default();
		void enseq_main_region_off_default();
		void enseq_main_region_off_r1_YellowOn_default();
		void enseq_main_region_off_r1_YellowOff_default();
		void enseq_main_region_default();
		void enseq_main_region_on_r1_default();
		void enseq_main_region_on_r1_PedWaiting_r1_default();
		void enseq_main_region_off_r1_default();
		void exseq_main_region_on();
		void exseq_main_region_on_r1_StreetGreen();
		void exseq_main_region_on_r1_PedWaiting();
		void exseq_main_region_on_r1_PedWaiting_r1_waitOn();
		void exseq_main_region_on_r1_PedWaiting_r1_waitOff();
		void exseq_main_region_on_r1_StreetAttention();
		void exseq_main_region_on_r1_StreetRed();
		void exseq_main_region_on_r1_PedestrianGreen();
		void exseq_main_region_on_r1_PedestrianRed();
		void exseq_main_region_on_r1_StreetPrepare();
		void exseq_main_region_on_r1_Safe();
		void exseq_main_region_off();
		void exseq_main_region_off_r1_YellowOn();
		void exseq_main_region_off_r1_YellowOff();
		void exseq_main_region();
		void exseq_main_region_on_r1();
		void exseq_main_region_on_r1_PedWaiting_r1();
		void exseq_main_region_off_r1();
		void react_main_region__entry_Default();
		void react_main_region_on_r1_PedWaiting_r1__entry_Default();
		void react_main_region_on_r1__entry_Default();
		void react_main_region_off_r1__entry_Default();
		sc::integer react(const sc::integer transitioned_before);
		sc::integer main_region_on_react(const sc::integer transitioned_before);
		sc::integer main_region_on_r1_StreetGreen_react(const sc::integer transitioned_before);
		sc::integer main_region_on_r1_PedWaiting_react(const sc::integer transitioned_before);
		sc::integer main_region_on_r1_PedWaiting_r1_waitOn_react(const sc::integer transitioned_before);
		sc::integer main_region_on_r1_PedWaiting_r1_waitOff_react(const sc::integer transitioned_before);
		sc::integer main_region_on_r1_StreetAttention_react(const sc::integer transitioned_before);
		sc::integer main_region_on_r1_StreetRed_react(const sc::integer transitioned_before);
		sc::integer main_region_on_r1_PedestrianGreen_react(const sc::integer transitioned_before);
		sc::integer main_region_on_r1_PedestrianRed_react(const sc::integer transitioned_before);
		sc::integer main_region_on_r1_StreetPrepare_react(const sc::integer transitioned_before);
		sc::integer main_region_on_r1_Safe_react(const sc::integer transitioned_before);
		sc::integer main_region_off_react(const sc::integer transitioned_before);
		sc::integer main_region_off_r1_YellowOn_react(const sc::integer transitioned_before);
		sc::integer main_region_off_r1_YellowOff_react(const sc::integer transitioned_before);
		void swapInEvents() noexcept;
		void clearInEvents() noexcept;
		void microStep();
		
		
		
		/*! Indicates event 'pedestrianRequest' of default interface scope is active. */
		bool pedestrianRequest_raised {false};
		
		/*! Indicates event 'onOff' of default interface scope is active. */
		bool onOff_raised {false};
		
		
		
};


inline TrafficLightCtrl::OperationCallback::~OperationCallback() {}


#endif /* TRAFFICLIGHTCTRL_H_ */
